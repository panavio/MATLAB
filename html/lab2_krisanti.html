<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>Integrator Lab: Solving First Order ODEs in MATLAB and Picard Approximation</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2023-10-02">
<meta name="DC.source" content="lab2_krisanti.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>Integrator Lab: Solving First Order ODEs in MATLAB and Picard Approximation</h1>
<!--introduction-->
<p>This lab will teach you to numerically solve first order ODEs using a built in MATLAB integrator, <tt>ode45</tt>.  <tt>ode45</tt> is a good, general purpose tool for integrating first order equations (and first order systems). It is not always the right algorithm, but it is usually the right algorithm to try first. This lab will also teach you how to manipulate symbolic functions in MATLAB.</p>
<p>You will learn how to use the <tt>ode45</tt> routine, how to interpolate between points, and how MATLAB handles data structures. You will also learn how to use MATLAB for exact symbolic calculations and write your own Picard approximation code.</p>
<p>Opening the m-file lab2.m in the MATLAB editor, step through each part using cell mode to see the results. Compare the output with the PDF, which was generated from this m-file.</p>
<p>There are eight exercises in this lab that are to be handed in at the end of the lab. Write your solutions in the template, including appropriate descriptions in each step. Save the .m file and submit it online using Quercus.</p>
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Student Information</a>
</li>
<li>
<a href="#2">Set up an inline function representation of an ODE and solve it</a>
</li>
<li>
<a href="#3">Examining the output</a>
</li>
<li>
<a href="#4">Understanding the components of the solution data structure</a>
</li>
<li>
<a href="#5">Visualizing and comparing the solution</a>
</li>
<li>
<a href="#6">Exercise 1</a>
</li>
<li>
<a href="#7">Computing an approximation at a specific point</a>
</li>
<li>
<a href="#8">Exercise 2</a>
</li>
<li>
<a href="#9">Errors, Step Sizes, and Tolerances</a>
</li>
<li>
<a href="#10">Exercise 3</a>
</li>
<li>
<a href="#11">Exercise 4</a>
</li>
<li>
<a href="#12">Exercise 5</a>
</li>
<li>
<a href="#13">Exercise 6 - When things go wrong</a>
</li>
<li>
<a href="#14">Using symbolic variables to define functions</a>
</li>
<li>
<a href="#17">Exercise 7</a>
</li>
<li>
<a href="#18">Obtaining Picard approximations</a>
</li>
<li>
<a href="#19">Exercise 8</a>
</li>
</ul>
</div>
<h2 id="1">Student Information</h2>
<p>Student Name: Patricia Nadia Krisanti</p>
<p>Student Number: 1009669404</p>
<h2 id="2">Set up an inline function representation of an ODE and solve it</h2>
<p>MATLAB has many built in routines for solving differential equations of the form</p>
<p>
<tt>y' = f(t,y)</tt>
</p>
<p>We will solve them using <tt>ode45</tt>, a high precision integrator. To do this, we will need to construct an inline function representation of <tt>f</tt>, an initial condition, and specify how far we want MATLAB to integrate the problem. Once we have set these, we pass the information to <tt>ode45</tt> to get the solution.</p>
<p>For a first example, we will solve the initial value problem</p>
<p>
<tt>y' = y, y(0) = 1</tt>
</p>
<p>which has as its answer <tt>y = e^t</tt>.</p>
<pre class="codeinput">
<span class="comment">% Set up the right hand side of the ODE as an inline function</span>
f = @(t,y) y;

<span class="comment">% The initial conditions</span>
t0 = 0;
y0 = 1;

<span class="comment">% The time we will integrate until</span>
t1 = 2

soln = ode45(f, [t0, t1], y0);
</pre>
<pre class="codeoutput">
t1 =

     2

</pre>
<h2 id="3">Examining the output</h2>
<p>When we execute the <tt>ode45</tt>, it returns a data structure, stored in soln. We can see the pieces of the data structure with a display command:</p>
<pre class="codeinput">disp(soln);
</pre>
<pre class="codeoutput">     solver: 'ode45'
    extdata: [1&times;1 struct]
          x: [0 0.2000 0.4000 0.6000 0.8000 1 1.2000 1.4000 1.6000 1.8000 2]
          y: [1 1.2214 1.4918 1.8221 2.2255 2.7183 3.3201 &hellip; ] (1&times;11 double)
      stats: [1&times;1 struct]
      idata: [1&times;1 struct]

</pre>
<h2 id="4">Understanding the components of the solution data structure</h2>
<p>The most important elements of the data structure are stored in the <tt>x</tt> and <tt>y</tt> components of the structure; these are vectors. Vectors <tt>x</tt> and <tt>y</tt> contain the points at which the numerical approximation to the initial vlaue problem has been computed. In other words, <tt>y(j)</tt> is the approximate value of the solution at <tt>x(j)</tt>.</p>
<p>
<b>NOTE:</b> Even though we may be studying a problem like <tt>u(t)</tt> or <tt>y(t)</tt>, MATLAB will always use <tt>x</tt> for the independent variable and <tt>y</tt> for the dependent variable in the data structure.</p>
<p>Pieces of the data structure can be accessed using a period, as in C/C++ or Java. See the examples below:</p>
<pre class="codeinput">
<span class="comment">% Display the values of |t| at which |y(t)| is approximated</span>
fprintf(<span class="string">' Vector of t values: '</span>);
disp(soln.x);
<span class="comment">% Display the the corresponding approximatations of |y(t)|</span>
fprintf(<span class="string">' Vector of y values: '</span>);
disp(soln.y);

<span class="comment">% Display the approximation of the solution at the 3rd point:</span>
fprintf(<span class="string">' Third element of the vector of t values: %g\n'</span>,soln.x(3));
fprintf(<span class="string">' Third element of the vector of y values: %g\n'</span>,soln.y(3));
</pre>
<pre class="codeoutput"> Vector of t values:   Columns 1 through 7

         0    0.2000    0.4000    0.6000    0.8000    1.0000    1.2000

  Columns 8 through 11

    1.4000    1.6000    1.8000    2.0000

 Vector of y values:   Columns 1 through 7

    1.0000    1.2214    1.4918    1.8221    2.2255    2.7183    3.3201

  Columns 8 through 11

    4.0552    4.9530    6.0496    7.3891

 Third element of the vector of t values: 0.4
 Third element of the vector of y values: 1.49182
</pre>
<h2 id="5">Visualizing and comparing the solution</h2>
<p>We can now visualize the solution at the computed data points and compare with the exact solution.</p>
<pre class="codeinput">
<span class="comment">% Construct the exact solution</span>
tt = linspace(0,2,50);
yy = exp(tt);

<span class="comment">% Plot both on the same figure, plotting the approximation with x's</span>
plot(tt, yy, soln.x, soln.y, <span class="string">'x'</span>, <span class="string">'MarkerSize'</span>,10, <span class="string">'LineWidth'</span>, 2);
<span class="comment">% NOTE: the MarkerSize and LineWidth are larger than their defaults of 6</span>
<span class="comment">% and 1, respectively.  This makes the print out more readable.</span>

<span class="comment">% Add a label to the axis and a legend</span>
xlabel(<span class="string">'t'</span>);
legend(<span class="string">'Exact'</span>, <span class="string">'Numerical'</span>,<span class="string">'Location'</span>,<span class="string">'Best'</span>);
</pre>
<img vspace="5" hspace="5" src="lab2_krisanti_01.png" alt=""> <h2 id="6">Exercise 1</h2>
<p>Objective: Solve an initial value problem and plot both the numerical approximation and the corresponding exact solution.</p>
<p>Details: Solve the IVP</p>
<p>
<tt>y' = y tan t + sin t, y(0) = -1/2</tt>
</p>
<p>from <tt>t = 0</tt> to <tt>t = pi</tt>.</p>
<p>Compute the exact solution (by hand), and plot both on the same figure for comparison, as above.</p>
<p>Your submission should show the construction of the inline function, the use of ode45 to obtain the solution, a construction of the exact solution, and a plot showing both. In the comments, include the exact solution.</p>
<p>Label your axes and include a legend.</p>
<pre class="codeinput">
<span class="comment">%making inline function</span>
f = @(t,y) y*tan(t)+sin(t);
<span class="comment">% The initial conditions</span>
t0 = 0;
y0 = -1/2;

<span class="comment">% The time we will integrate until</span>
t1 = pi

<span class="comment">%obtaining solution using ode45</span>
sol = ode45(f, [t0, t1], y0);
<span class="comment">%plot(sol.x,sol.y)</span>

<span class="comment">%exact solution of y' = y tan t + sin t, y(0) = -1/2 is</span>
<span class="comment">% y=-cos(x)/2</span>

<span class="comment">%constructing exact solution</span>
x=linspace(0,pi,1000);
y=-cos(x)/2;

<span class="comment">%plotting exact and approximated solutions</span>
plot(x,y, sol.x, sol.y,<span class="string">'x'</span>, <span class="string">'MarkerSize'</span>,10, <span class="string">'LineWidth'</span>, 2 )
xlabel(<span class="string">'t'</span>)
ylabel(<span class="string">'y(t)'</span>)
legend(<span class="string">'by hand'</span>, <span class="string">'using ode45'</span>);
</pre>
<pre class="codeoutput">
t1 =

    3.1416

</pre>
<img vspace="5" hspace="5" src="lab2_krisanti_02.png" alt=""> <h2 id="7">Computing an approximation at a specific point</h2>
<p>As you should be able to see by examining <tt>soln.x</tt>, ode45 returns the solution at a number of points between <tt>t0</tt> and <tt>t1</tt>. But sometimes we want to know the solution at some intermediate point.</p>
<p>To obtain this value, we need to interpolate it in a consistent way. Fortunately, MATLAB provides a convenient function, <tt>deval</tt>, specifically for this.</p>
<pre class="codeinput">
<span class="comment">% Compute the solution at t = .25:</span>
deval(soln, .25)

<span class="comment">% Compute the solution at t = 1.6753:</span>
fprintf(<span class="string">' Solution at 1.6753: %g\n'</span>, deval(soln, 1.6753));

<span class="comment">% Compute the solution at 10 grid points between .45 and 1.65:</span>
tinterp = linspace(.45, 1.65, 10);
deval(soln, tinterp)

<span class="comment">% Alternatively:</span>
deval(soln, linspace(.45, 1.65, 10))
</pre>
<pre class="codeoutput">
ans =

    1.2840

 Solution at 1.6753: 5.3404

ans =

  Columns 1 through 7

    1.5683    1.7920    2.0476    2.3396    2.6734    3.0547    3.4903

  Columns 8 through 10

    3.9882    4.5570    5.2070


ans =

  Columns 1 through 7

    1.5683    1.7920    2.0476    2.3396    2.6734    3.0547    3.4903

  Columns 8 through 10

    3.9882    4.5570    5.2070

</pre>
<h2 id="8">Exercise 2</h2>
<p>Objective: Interpolate a solution at a number of grid points</p>
<p>Details: For the solution you computed in exercise 1, use deval to compute the interpolated values at 10 grid points between 2 and 3.</p>
<pre class="codeinput">interp=linspace(2,3,10);
deval(sol,interp)
</pre>
<pre class="codeoutput">
ans =

  Columns 1 through 7

    0.2081    0.2572    0.3032    0.3454    0.3833    0.4166    0.4447

  Columns 8 through 10

    0.4673    0.4841    0.4950

</pre>
<h2 id="9">Errors, Step Sizes, and Tolerances</h2>
<p>As you may have noticed, in contrast to the IODE software, at no point do we set a step size for our solution. Indeed, the step size is set adaptively to conform to a specified error tolerance.</p>
<p>Roughly speaking, given the solution at <tt>(t_j, y_j)</tt>, <tt>ode45</tt> computes two approximations of the solution at <tt>t_{j+1} = t_j + h</tt>; one is of greater accuracy than the other. If the difference is below a specified tolerance, the step is accepted and we continue. Otherwise the step is rejected and the smaller step size, <tt>h</tt>, is used; it is often halved.</p>
<p>We can compute the global truncation error at each solution point, figure out the maximum error, and visualize this error (on a linear-log scale):</p>
<pre class="codeinput">
<span class="comment">% Compute the exact solution</span>
yexact = exp(soln.x);

<span class="comment">% Compute the pointwise error; note the use of MATLAB's vectorization</span>
err = abs(yexact - soln.y);

disp(err);

fprintf(<span class="string">'maximum error: %g \n'</span>, max(err));

semilogy(soln.x, err, <span class="string">'LineWidth'</span>, 2);
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'error'</span>);
</pre>
<pre class="codeoutput">   1.0e-06 *

  Columns 1 through 7

         0    0.0152    0.0371    0.0679    0.1106    0.1688    0.2475

  Columns 8 through 11

    0.3526    0.4922    0.6764    0.9179

maximum error: 9.17923e-07 
</pre>
<img vspace="5" hspace="5" src="lab2_krisanti_03.png" alt=""> <h2 id="10">Exercise 3</h2>
<p>Objective: Examine the error of a solution generated by <tt>ode45</tt>
</p>
<p>Details: For your solution to exercise 1, compute the pointwise error, identify the maximum value of the error, and visualize the error on a linear-log plot (use semilogy to plot the log of the error vs. t). Write in the comments where the error is largest, and give a brief (1-2 sentences) explanation of why it is largest there. Make sure to label your axes.</p>
<pre class="codeinput">
<span class="comment">% exact solution</span>
yex = -cos(sol.x)/2;

<span class="comment">% pointwise error</span>
err = abs(yex - sol.y);

disp(err);

<span class="comment">%maximum value of the error</span>
fprintf(<span class="string">'maximum error: %g \n'</span>, max(err));

<span class="comment">%plotting the error on a linear-log plot</span>
semilogy(sol.x, err, <span class="string">'LineWidth'</span>, 2);
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'error'</span>);

<span class="comment">%highest error is when t is approximately 1.6 or pi/2, the error is highest in</span>
<span class="comment">%t=1.6 or pi/2 because as the ode45 approximates the value along the graph,</span>
<span class="comment">%it assumes that the graph is continuous.</span>
<span class="comment">% However, in the ODE dy/dx =y*tan(t)+sin(t), tan(t) is not continuous on</span>
<span class="comment">% pi/2. tan(t) has an asympote, which causes the huge spike of error on the</span>
<span class="comment">% approximation as the value of tan(t) is undefined.</span>
</pre>
<pre class="codeoutput">   1.0e-04 *

  Columns 1 through 7

         0    0.0001    0.0006    0.0021    0.0070    0.0077    0.0087

  Columns 8 through 14

    0.0230    0.0408    0.1807    0.0254    0.0114    0.0068    0.0055

  Columns 15 through 17

    0.0047    0.0043    0.0043

maximum error: 1.8068e-05 
</pre>
<img vspace="5" hspace="5" src="lab2_krisanti_04.png" alt=""> <h2 id="11">Exercise 4</h2>
<p>Objective: Solve and visualize a nonlinear ode using ode45</p>
<p>Details: Solve the IVP</p>
<p>
<tt>y' = 1 / y^2 , y(1) = 1</tt>
</p>
<p>from <tt>t=1</tt> to <tt>t=10</tt> using <tt>ode45</tt>. Find the exact solution and compute the maximum pointwise error. Then plot the approximate solution and the exact solution on the same axes.</p>
<p>Your solution should show the definition of the inline function, the computation of its solution in this interval, the computation of the exact solution at the computed grid points, the computation of the maximum error, and a plot of the exact and approximate solutions.</p>
<pre class="codeinput">
<span class="comment">%Your axes should be appropriately labeled and include a legend.</span>
clear <span class="string">all</span>

f = @(t,y) 1 ./ (y.^2);

<span class="comment">% The initial conditions</span>
t0 = 1;
y0 = 1;

<span class="comment">% The time we will integrate until</span>
t1 = 10

<span class="comment">%computing approximate points</span>
sol = ode45(f, [t0, t1], y0);

<span class="comment">%computing exact points</span>
x=linspace(1,10,1000);
y=(3*x).^(1/3);


<span class="comment">%plotting exact and approximate solutions</span>
plot(x,y, sol.x, sol.y,<span class="string">'x'</span>, <span class="string">'MarkerSize'</span>,10, <span class="string">'LineWidth'</span>, 2 )
xlabel(<span class="string">'t'</span>)
ylabel(<span class="string">'y(t)'</span>)
legend(<span class="string">'by hand'</span>, <span class="string">'using ode45'</span>);

grid <span class="string">on</span>

<span class="comment">% exact solution</span>
yex =(3*sol.x).^(1/3);

<span class="comment">% pointwise error</span>
err = abs(yex - sol.y);

disp(err);

<span class="comment">%maximum error</span>
fprintf(<span class="string">'maximum error: %g \n'</span>, max(err));
</pre>
<pre class="codeoutput">
t1 =

    10

  Columns 1 through 7

    0.4422    0.3627    0.2224    0.1684    0.1385    0.1191    0.1054

  Columns 8 through 12

    0.0950    0.0869    0.0803    0.0748    0.0711

maximum error: 0.44225 
</pre>
<img vspace="5" hspace="5" src="lab2_krisanti_05.png" alt=""> <h2 id="12">Exercise 5</h2>
<p>Objective: Solve and visualize an ODE that cannot be solved by hand with <tt>ode45</tt>.</p>
<p>Details: Solve the IVP</p>
<p>
<tt>y' = 1 - t y / 2, y(0) = -1</tt>
</p>
<p>from <tt>t=0</tt> to <tt>t=10</tt>.</p>
<p>Your solution should show you defining the inline function, computing the solution in this interval, and plotting it.</p>
<p>Your axes should be appropriately labeled</p>
<pre class="codeinput">
<span class="comment">%defining inline function</span>
f = @(y,t) 1 - (t.*y)./ 2



<span class="comment">%computing solution in the interval</span>
sol=ode45(f, [0,10],-1)

<span class="comment">%plotting the graph</span>
plot(sol.x,sol.y)

xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'y(t)'</span>);
</pre>
<pre class="codeoutput">
f =

  function_handle with value:

    @(y,t)1-(t.*y)./2


sol = 

  struct with fields:

     solver: 'ode45'
    extdata: [1&times;1 struct]
          x: [0 0.2010 1.2010 2.2010 2.8484 3.4958 4.1908 &hellip; ] (1&times;17 double)
          y: [-1 -0.7904 0.2527 0.7541 0.7677 0.6727 0.5530 &hellip; ] (1&times;17 double)
      stats: [1&times;1 struct]
      idata: [1&times;1 struct]

</pre>
<img vspace="5" hspace="5" src="lab2_krisanti_06.png" alt=""> <h2 id="13">Exercise 6 - When things go wrong</h2>
<p>Objective: Solve an ode and explain the warning message</p>
<p>Details: Solve the IVP:</p>
<p>
<tt>y' = y^3 - t^2, y(0) = 1</tt>
</p>
<p>from <tt>t=0</tt> to <tt>t=1</tt>.</p>
<p>Your solution should show you defining the inline function, and computing the solution in this interval.</p>
<p>If you try to plot the solution, you should find that the solution does not make it all the way to t = 1.</p>
<p>In the comments explain why MATLAB generates the warning message that you may see, or fails to integrate all the way to t=1. HINT: Try plotting the direction field for this with IODE.</p>
<pre class="codeinput">
<span class="comment">%defining inline function</span>
f = @(t,y) y.^3 - t.^2;
<span class="comment">% The initial conditions</span>
t0 = 0;
y0 = 1;

<span class="comment">% The time we will integrate until</span>
t1 = 1

sol = ode45(f, [t0, t1], y0);
<span class="comment">%plot(sol.x,sol.y)</span>
plot(sol.x, sol.y)
xlabel(<span class="string">'t'</span>)
ylabel(<span class="string">'y(t)'</span>)
legend( <span class="string">'using ode45'</span>);
<span class="comment">%Error Message:</span>
<span class="comment">%Failure at t=5.066046e-01. Unable to meet integration tolerances without</span>
<span class="comment">%reducing the step size below the smallest value allowed (1.776357e-15) at</span>
<span class="comment">%time t.</span>
<span class="comment">%This error is caused by the ODE45 not being able to meet the integration</span>
<span class="comment">%tolerance or error limit that was being set. This is caused by the step size that is too large,</span>
<span class="comment">%which increases the difference between the exact solution and the</span>
<span class="comment">%aproximated solution, or the error in the solution.</span>
</pre>
<pre class="codeoutput">
t1 =

     1

</pre>
<img vspace="5" hspace="5" src="lab2_krisanti_07.png" alt=""> <h2 id="14">Using symbolic variables to define functions</h2>
<p>We can define symbolic variables to let MATLAB know that these variables will be used for exact computations</p>
<pre class="codeinput">
<span class="comment">% Start by defining the variables as symbolic</span>
syms <span class="string">t</span> <span class="string">s</span> <span class="string">x</span> <span class="string">y</span>

<span class="comment">% Define a function by simply writing its expression</span>

f = cos(t)
g = sin(t)
h = exp(2*x)

<span class="comment">% We can manipulate these functions</span>

simplify(f^2+g^2)
diff(h)

<span class="comment">% We can plot a function defined symbolically using the command |ezplot|.</span>
<span class="comment">% Learn about the command |ezplot|:</span>

help <span class="string">ezplot</span>

<span class="comment">% Plot the function |f(t)| and |h(x)|</span>

ezplot(f)
ezplot(h)
</pre>
<pre class="codeoutput"> 
f =
 
cos(t)
 
 
g =
 
sin(t)
 
 
h =
 
exp(2*x)
 
 
ans =
 
1
 
 
ans =
 
2*exp(2*x)
 
 EZPLOT   (NOT RECOMMENDED) Easy to use function plotter
 
  ==========================================================
  EZPLOT is not recommended. Use FPLOT or FIMPLICIT instead.
  ==========================================================
 
    EZPLOT(FUN) plots the function FUN(X) over the default domain
    -2*PI &lt; X &lt; 2*PI, where FUN(X) is an explicitly defined function of X.
 
    EZPLOT(FUN2) plots the implicitly defined function FUN2(X,Y) = 0 over
    the default domain -2*PI &lt; X &lt; 2*PI and -2*PI &lt; Y &lt; 2*PI.
 
    EZPLOT(FUN,[A,B]) plots FUN(X) over A &lt; X &lt; B.
    EZPLOT(FUN2,[A,B]) plots FUN2(X,Y) = 0 over A &lt; X &lt; B and A &lt; Y &lt; B.
 
    EZPLOT(FUN2,[XMIN,XMAX,YMIN,YMAX]) plots FUN2(X,Y) = 0 over
    XMIN &lt; X &lt; XMAX and YMIN &lt; Y &lt; YMAX.
 
    EZPLOT(FUNX,FUNY) plots the parametrically defined planar curve FUNX(T)
    and FUNY(T) over the default domain 0 &lt; T &lt; 2*PI.
 
    EZPLOT(FUNX,FUNY,[TMIN,TMAX]) plots FUNX(T) and FUNY(T) over
    TMIN &lt; T &lt; TMAX.
 
    EZPLOT(FUN,[A,B],FIG), EZPLOT(FUN2,[XMIN,XMAX,YMIN,YMAX],FIG), or
    EZPLOT(FUNX,FUNY,[TMIN,TMAX],FIG) plots the function over the
    specified domain in the figure window FIG.
 
    EZPLOT(AX,...) plots into AX instead of GCA or FIG.
 
    H = EZPLOT(...) returns handles to the plotted objects in H.
 
    Examples:
    The easiest way to express a function is via a string:
       ezplot('x^2 - 2*x + 1')
 
    One programming technique is to vectorize the string expression using
    the array operators .* (TIMES), ./ (RDIVIDE), .\ (LDIVIDE), .^ (POWER).
    This makes the algorithm more efficient since it can perform multiple
    function evaluations at once.
       ezplot('x.*y + x.^2 - y.^2 - 1')
 
    You may also use a function handle to an existing function. Function
    handles are more powerful and efficient than string expressions.
       ezplot(@humps)
       ezplot(@cos,@sin)
 
    EZPLOT plots the variables in string expressions alphabetically.
       subplot(1,2,1), ezplot('1./z - log(z) + log(-1+z) + t - 1')
    To avoid this ambiguity, specify the order with an anonymous function:
       subplot(1,2,2), ezplot(@(z,t)1./z - log(z) + log(-1+z) + t - 1)
 
    If your function has additional parameters, for example k in myfun:
       %-----------------------%
       function z = myfun(x,y,k)
       z = x.^k - y.^k - 1;
       %-----------------------%
    then you may use an anonymous function to specify that parameter:
       ezplot(@(x,y)myfun(x,y,2))
 
    See also EZCONTOUR, EZCONTOURF, EZMESH, EZMESHC, EZPLOT3, EZPOLAR,
             EZSURF, EZSURFC, PLOT, VECTORIZE, FUNCTION_HANDLE.

    Documentation for ezplot
       doc ezplot

    Other uses of ezplot

       sym/ezplot

</pre>
<img vspace="5" hspace="5" src="lab2_krisanti_08.png" alt=""> <p>If we try to evaluate the function <tt>f(0)</tt>, we get an error message.</p>
<p>The symbolic variables are not meant to be used to evaluate functions, but to manipulate functions, compute derivatives, etc. To evaluate a function using symbolic variables is a little cumbersome:</p>
<pre class="codeinput">
<span class="comment">% We need to substitute the variable by a value:</span>

subs(f,t,pi)
</pre>
<pre class="codeoutput"> 
ans =
 
-1
 
</pre>
<p>This expression means: In the expression <tt>f</tt>, substitute the variable <tt>t</tt> by the number <tt>pi</tt>.</p>
<pre class="codeinput">
<span class="comment">% If we use a value where the cosine does not have a "nice" expression, we</span>
<span class="comment">% need to approximate the result:</span>

subs(f,t,2)

<span class="comment">% We need to use the command |eval|</span>

eval(subs(f,t,2))
</pre>
<pre class="codeoutput"> 
ans =
 
cos(2)
 

ans =

   -0.4161

</pre>
<h2 id="17">Exercise 7</h2>
<p>Objective: Define a function using symbolic variables and manipulate it.</p>
<p>Details: Define the function <tt>f(x) = sin(x)cos(x)</tt>
</p>
<p>Use MATLAB commands to obtain a simpler form of this function, compute value of this function for <tt>x=pi/4</tt> and <tt>x=1</tt>, and plot its graph.</p>
<pre class="codeinput">syms <span class="string">x</span>
<span class="comment">%make the 2 functions</span>
a=sin(x)
b=cos(x)

<span class="comment">%combine the 2 functions</span>
S=simplify(a.*b)

<span class="comment">%evaluate the value of x=pi/4 and x=1 on the function</span>
fprintf(<span class="string">'at x=pi/4, f(x)=%g'</span>,subs(S,x,pi/4))
fprintf(<span class="string">'at x=1, f(x)=%g'</span>,subs(S,x,1))
<span class="comment">%plotting using ezplot</span>
ezplot(a*b)
ylabel(<span class="string">'y(x)'</span>)
</pre>
<pre class="codeoutput"> 
a =
 
sin(x)
 
 
b =
 
cos(x)
 
 
S =
 
sin(2*x)/2
 
at x=pi/4, f(x)=0.5at x=1, f(x)=0.454649</pre>
<img vspace="5" hspace="5" src="lab2_krisanti_09.png" alt=""> <h2 id="18">Obtaining Picard approximations</h2>
<p>Consider an initial value problem</p>
<p>
<tt>y' = 1 + y</tt> <tt>y(0) = 0</tt>
</p>
<p>First we need to define the variables we will be using</p>
<pre class="codeinput">syms <span class="string">t</span> <span class="string">s</span> <span class="string">y</span>;

<span class="comment">% We then need to define the function f</span>

f = 1+y <span class="comment">% we define it without the @(t,y) because it is a symbolic function</span>

<span class="comment">% We set up our initial approximation phi_0 = 0:</span>

phi=[sym(0)]  <span class="comment">% we will keep a list with all the approximations</span>

<span class="comment">% Set up a loop to get successive approximations using Picard iterations</span>

N=5;

<span class="keyword">for</span> i = 1:N
    func=subs(f,y,phi(i));    <span class="comment">% prepare function to integrate: y -&gt; previous phi</span>
    func=subs(func,t,s);      <span class="comment">% variable of integration is s, so we need to change</span>
                              <span class="comment">% t -&gt; s</span>

    newphi = int(func, s, 0 ,t);   <span class="comment">% integrate to find next approximation</span>

    phi=cat(2,phi,[newphi]);       <span class="comment">% update the list of approximations by adding new phi</span>
<span class="keyword">end</span>

<span class="comment">% Show the last approximation</span>
phi
phi(N+1)

<span class="comment">% Plot the approximation just found</span>

picard=ezplot(phi(N+1),[0,5])
set(picard,<span class="string">'Color'</span>,<span class="string">'green'</span>)         <span class="comment">% set the color of the graph to green</span>

<span class="comment">% In this case, the exact solution is</span>
<span class="comment">%</span>
<span class="comment">% |y=e^t-1|</span>
<span class="comment">%</span>
<span class="comment">% Compare the approximation and the exact solutions</span>

hold <span class="string">on</span>;
exact=ezplot(exp(t)-1,[0,5]);

xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'y'</span>);
title(<span class="string">'Picard Approximations'</span>);
legend(<span class="string">'Picard Approximation'</span>, <span class="string">'Exact Solution'</span>,<span class="string">'Location'</span>,<span class="string">'NorthWest'</span>);
clear <span class="string">all</span>
</pre>
<pre class="codeoutput"> 
f =
 
y + 1
 
 
phi =
 
0
 
 
phi =
 
[0, t, (t*(t + 2))/2, (t*(t^2 + 3*t + 6))/6, (t*(t^3 + 4*t^2 + 12*t + 24))/24, (t*(t^4 + 5*t^3 + 20*t^2 + 60*t + 120))/120]
 
 
ans =
 
(t*(t^4 + 5*t^3 + 20*t^2 + 60*t + 120))/120
 

picard = 

  Line with properties:

              Color: [0 0.4470 0.7410]
          LineStyle: '-'
          LineWidth: 0.5000
             Marker: 'none'
         MarkerSize: 6
    MarkerFaceColor: 'none'
              XData: [0 0.0115 0.0231 0.0346 0.0462 0.0577 &hellip; ] (1&times;434 double)
              YData: [0 0.0116 0.0234 0.0352 0.0473 0.0594 &hellip; ] (1&times;434 double)

  Use GET to show all properties

</pre>
<img vspace="5" hspace="5" src="lab2_krisanti_10.png" alt=""> <h2 id="19">Exercise 8</h2>
<pre>Objective: Solve your own Picard Approximation and compare it to the
exact solution.</pre>
<pre>Details: Consider the IVP
   | y' = 1+y^2|
   | y(0) = 1 |</pre>
<p>Find the Picard approximation phi_5. For better efficiency, do not keep all the previous approximations.</p>
<p>Compute the exact solution (by hand), and plot both on the same figure for comparison, as above.</p>
<p>Label your axes and include a legend.</p>
<p>HINT. The initial condition has 1 instead of 0, so the Picard method needs to be adapted.</p>
<pre class="codeinput">syms <span class="string">t</span> <span class="string">s</span> <span class="string">y</span>;

<span class="comment">% We then need to define the function f</span>

f = 1+y.^2 <span class="comment">% we define it without the @(t,y) because it is a symbolic function</span>

<span class="comment">% We set up our initial approximation phi_0 = 0:</span>

phi=[sym(1)]  <span class="comment">% we will keep a list with all the approximations</span>

<span class="comment">% Set up a loop to get successive approximations using Picard iterations</span>

N=5;

<span class="keyword">for</span> i = 1:N
    func=subs(f,y,phi(i));    <span class="comment">% prepare function to integrate: y -&gt; previous phi</span>
    func=subs(func,t,s);      <span class="comment">% variable of integration is s, so we need to change</span>
                              <span class="comment">% t -&gt; s</span>

    newphi = int(func, s, 0 ,t);   <span class="comment">% integrate to find next approximation</span>

    phi=cat(2,phi,[newphi]);       <span class="comment">% update the list of approximations by adding new phi</span>
<span class="keyword">end</span>

<span class="comment">% Show the last approximation</span>

phi(N+1)

<span class="comment">% Plot the approximation just found</span>

picard=ezplot(phi(N+1),[0,5]);
set(picard,<span class="string">'Color'</span>,<span class="string">'green'</span>);         <span class="comment">% set the color of the graph to green</span>

<span class="comment">% In this case, the exact solution is</span>
<span class="comment">%</span>
<span class="comment">% |y=tan(t)|</span>
<span class="comment">%</span>
<span class="comment">% Compare the approximation and the exact solutions</span>

hold <span class="string">on</span>;
exact=ezplot(tan(t),[0,5]);

xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'y'</span>);
title(<span class="string">'Picard Approximations'</span>);
legend(<span class="string">'Picard Approximation'</span>, <span class="string">'Exact Solution'</span>,<span class="string">'Location'</span>,<span class="string">'NorthWest'</span>);
clear <span class="string">all</span>
</pre>
<pre class="codeoutput"> 
f =
 
y^2 + 1
 
 
phi =
 
1
 
 
ans =
 
(65536*t^31)/109876902975 + (131072*t^29)/21210236775 + (412598272*t^27)/14119435204875 + (307044352*t^25)/3016973334375 + (5270947328*t^23)/16962094524375 + (30791168*t^21)/40226311125 + (181075264*t^19)/109185701625 + (6000032*t^17)/1550674125 + (5238853*t^15)/638512875 + (3580*t^13)/243243 + (4562*t^11)/155925 + (134*t^9)/2835 + (17*t^7)/315 + (2*t^5)/15 + t^3/3 + t
 
</pre>
<img vspace="5" hspace="5" src="lab2_krisanti_11.png" alt=""> <p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% Integrator Lab: Solving First Order ODEs in MATLAB and Picard Approximation
% This lab will teach you to numerically solve first order ODEs using a built 
% in MATLAB integrator, |ode45|.  |ode45| is a good, general purpose tool for 
% integrating first order equations (and first order systems). It is not always 
% the right algorithm, but it is usually the right algorithm to try first. This 
% lab will also teach you how to manipulate symbolic functions in MATLAB.
% 
% You will learn how to use the |ode45| routine, how to interpolate between 
% points, and how MATLAB handles data structures. You will also learn how to use 
% MATLAB for exact symbolic calculations and write your own Picard approximation 
% code.
% 
% Opening the m-file lab2.m in the MATLAB editor, step through each part using 
% cell mode to see the results. Compare the output with the PDF, which was generated 
% from this m-file.
% 
% There are eight exercises in this lab that are to be handed in at the end 
% of the lab. Write your solutions in the template, including appropriate descriptions 
% in each step. Save the .m file and submit it online using Quercus.
%% Student Information
% Student Name: Patricia Nadia Krisanti
% 
% Student Number: 1009669404
%% Set up an inline function representation of an ODE and solve it
% MATLAB has many built in routines for solving differential equations of the 
% form
% 
% |y' = f(t,y)|
% 
% We will solve them using |ode45|, a high precision integrator. To do this, 
% we will need to construct an inline function representation of |f|, an initial 
% condition, and specify how far we want MATLAB to integrate the problem. Once 
% we have set these, we pass the information to |ode45| to get the solution.
% 
% For a first example, we will solve the initial value problem
% 
% |y' = y, y(0) = 1|
% 
% which has as its answer |y = e^t|. 

% Set up the right hand side of the ODE as an inline function
f = @(t,y) y; 

% The initial conditions
t0 = 0;
y0 = 1;

% The time we will integrate until
t1 = 2

soln = ode45(f, [t0, t1], y0);
%% Examining the output
% When we execute the |ode45|, it returns a data structure, stored in soln. 
% We can see the pieces of the data structure with a display command:

disp(soln);
%% Understanding the components of the solution data structure
% The most important elements of the data structure are stored in the |x| and 
% |y| components of the structure; these are vectors. Vectors |x| and |y| contain 
% the points at which the numerical approximation to the initial vlaue problem 
% has been computed. In other words, |y(j)| is the approximate value of the solution 
% at |x(j)|.
% 
% *NOTE:* Even though we may be studying a problem like |u(t)| or |y(t)|, MATLAB 
% will always use |x| for the independent variable and |y| for the dependent variable 
% in the data structure.
% 
% Pieces of the data structure can be accessed using a period, as in C/C++ or 
% Java. See the examples below:

% Display the values of |t| at which |y(t)| is approximated
fprintf(' Vector of t values: ');
disp(soln.x);
% Display the the corresponding approximatations of |y(t)|
fprintf(' Vector of y values: ');
disp(soln.y);

% Display the approximation of the solution at the 3rd point:
fprintf(' Third element of the vector of t values: %g\n',soln.x(3));
fprintf(' Third element of the vector of y values: %g\n',soln.y(3));
%% Visualizing and comparing the solution
% We can now visualize the solution at the computed data points and compare 
% with the exact solution.

% Construct the exact solution
tt = linspace(0,2,50);
yy = exp(tt);

% Plot both on the same figure, plotting the approximation with x's
plot(tt, yy, soln.x, soln.y, 'x', 'MarkerSize',10, 'LineWidth', 2);
% NOTE: the MarkerSize and LineWidth are larger than their defaults of 6
% and 1, respectively.  This makes the print out more readable.

% Add a label to the axis and a legend
xlabel('t');
legend('Exact', 'Numerical','Location','Best');
%% Exercise 1
% Objective: Solve an initial value problem and plot both the numerical approximation 
% and the corresponding exact solution.
% 
% Details: Solve the IVP
% 
% |y' = y tan t + sin t, y(0) = -1/2|
% 
% from |t = 0| to |t = pi|.
% 
% Compute the exact solution (by hand), and plot both on the same figure for 
% comparison, as above.
% 
% Your submission should show the construction of the inline function, the use 
% of ode45 to obtain the solution, a construction of the exact solution, and a 
% plot showing both. In the comments, include the exact solution.
% 
% Label your axes and include a legend.

%making inline function
f = @(t,y) y*tan(t)+sin(t);
% The initial conditions
t0 = 0;
y0 = -1/2;

% The time we will integrate until
t1 = pi

%obtaining solution using ode45
sol = ode45(f, [t0, t1], y0);
%plot(sol.x,sol.y)

%exact solution of y' = y tan t + sin t, y(0) = -1/2 is 
% y=-cos(x)/2

%constructing exact solution
x=linspace(0,pi,1000);
y=-cos(x)/2;

%plotting exact and approximated solutions
plot(x,y, sol.x, sol.y,'x', 'MarkerSize',10, 'LineWidth', 2 )
xlabel('t')
ylabel('y(t)')
legend('by hand', 'using ode45');
%% Computing an approximation at a specific point
% As you should be able to see by examining |soln.x|, ode45 returns the solution 
% at a number of points between |t0| and |t1|. But sometimes we want to know the 
% solution at some intermediate point.
% 
% To obtain this value, we need to interpolate it in a consistent way. Fortunately, 
% MATLAB provides a convenient function, |deval|, specifically for this.

% Compute the solution at t = .25:
deval(soln, .25)

% Compute the solution at t = 1.6753:
fprintf(' Solution at 1.6753: %g\n', deval(soln, 1.6753));

% Compute the solution at 10 grid points between .45 and 1.65:
tinterp = linspace(.45, 1.65, 10);
deval(soln, tinterp)

% Alternatively:
deval(soln, linspace(.45, 1.65, 10))
%% Exercise 2
% Objective: Interpolate a solution at a number of grid points
% 
% Details: For the solution you computed in exercise 1, use deval to compute 
% the interpolated values at 10 grid points between 2 and 3.

interp=linspace(2,3,10);
deval(sol,interp)
%% Errors, Step Sizes, and Tolerances
% As you may have noticed, in contrast to the IODE software, at no point do 
% we set a step size for our solution. Indeed, the step size is set adaptively 
% to conform to a specified error tolerance. 
% 
% Roughly speaking, given the solution at |(t_j, y_j)|, |ode45| computes two 
% approximations of the solution at |t_{j+1} = t_j + h|; one is of greater accuracy 
% than the other. If the difference is below a specified tolerance, the step is 
% accepted and we continue. Otherwise the step is rejected and the smaller step 
% size, |h|, is used; it is often halved.
% 
% We can compute the global truncation error at each solution point, figure 
% out the maximum error, and visualize this error (on a linear-log scale):

% Compute the exact solution
yexact = exp(soln.x);

% Compute the pointwise error; note the use of MATLAB's vectorization
err = abs(yexact - soln.y);

disp(err);

fprintf('maximum error: %g \n', max(err));

semilogy(soln.x, err, 'LineWidth', 2);
xlabel('t');
ylabel('error');
%% Exercise 3
% Objective: Examine the error of a solution generated by |ode45|
% 
% Details: For your solution to exercise 1, compute the pointwise error, identify 
% the maximum value of the error, and visualize the error on a linear-log plot 
% (use semilogy to plot the log of the error vs. t). Write in the comments where 
% the error is largest, and give a brief (1-2 sentences) explanation of why it 
% is largest there. Make sure to label your axes.

% exact solution
yex = -cos(sol.x)/2;

% pointwise error
err = abs(yex - sol.y);

disp(err);

%maximum value of the error
fprintf('maximum error: %g \n', max(err));

%plotting the error on a linear-log plot
semilogy(sol.x, err, 'LineWidth', 2);
xlabel('t');
ylabel('error');

%highest error is when t is approximately 1.6 or pi/2, the error is highest in
%t=1.6 or pi/2 because as the ode45 approximates the value along the graph,
%it assumes that the graph is continuous. 
% However, in the ODE dy/dx =y*tan(t)+sin(t), tan(t) is not continuous on
% pi/2. tan(t) has an asympote, which causes the huge spike of error on the
% approximation as the value of tan(t) is undefined.
%% Exercise 4
% Objective: Solve and visualize a nonlinear ode using ode45
% 
% Details: Solve the IVP
% 
% |y' = 1 / y^2 , y(1) = 1|
% 
% from |t=1| to |t=10| using |ode45|. Find the exact solution and compute the 
% maximum pointwise error. Then plot the approximate solution and the exact solution 
% on the same axes.
% 
% Your solution should show the definition of the inline function, the computation 
% of its solution in this interval, the computation of the exact solution at the 
% computed grid points, the computation of the maximum error, and a plot of the 
% exact and approximate solutions.

%Your axes should be appropriately labeled and include a legend.
clear all

f = @(t,y) 1 ./ (y.^2);

% The initial conditions
t0 = 1;
y0 = 1;

% The time we will integrate until
t1 = 10

%computing approximate points
sol = ode45(f, [t0, t1], y0);

%computing exact points
x=linspace(1,10,1000);
y=(3*x).^(1/3);


%plotting exact and approximate solutions
plot(x,y, sol.x, sol.y,'x', 'MarkerSize',10, 'LineWidth', 2 )
xlabel('t')
ylabel('y(t)')
legend('by hand', 'using ode45');

grid on

% exact solution
yex =(3*sol.x).^(1/3);

% pointwise error
err = abs(yex - sol.y);

disp(err);

%maximum error
fprintf('maximum error: %g \n', max(err));

%% Exercise 5
% Objective: Solve and visualize an ODE that cannot be solved by hand with |ode45|.
% 
% Details: Solve the IVP
% 
% |y' = 1 - t y / 2, y(0) = -1|
% 
% from |t=0| to |t=10|. 
% 
% Your solution should show you defining the inline function, computing the 
% solution in this interval, and plotting it.
% 
% Your axes should be appropriately labeled

%defining inline function
f = @(y,t) 1 - (t.*y)./ 2



%computing solution in the interval
sol=ode45(f, [0,10],-1)

%plotting the graph
plot(sol.x,sol.y)

xlabel('t');
ylabel('y(t)');

%% Exercise 6 - When things go wrong
% Objective: Solve an ode and explain the warning message
% 
% Details: Solve the IVP:
% 
% |y' = y^3 - t^2, y(0) = 1|
% 
% from |t=0| to |t=1|. 
% 
% Your solution should show you defining the inline function, and computing 
% the solution in this interval.
% 
% If you try to plot the solution, you should find that the solution does not 
% make it all the way to t = 1.
% 
% In the comments explain why MATLAB generates the warning message that you 
% may see, or fails to integrate all the way to t=1. HINT: Try plotting the direction 
% field for this with IODE.

%defining inline function
f = @(t,y) y.^3 - t.^2;
% The initial conditions
t0 = 0;
y0 = 1;

% The time we will integrate until
t1 = 1

sol = ode45(f, [t0, t1], y0);
%plot(sol.x,sol.y)
plot(sol.x, sol.y)
xlabel('t')
ylabel('y(t)')
legend( 'using ode45');
%Error Message: 
%Failure at t=5.066046e-01. Unable to meet integration tolerances without 
%reducing the step size below the smallest value allowed (1.776357e-15) at
%time t.
%This error is caused by the ODE45 not being able to meet the integration
%tolerance or error limit that was being set. This is caused by the step size that is too large,
%which increases the difference between the exact solution and the
%aproximated solution, or the error in the solution.
%% Using symbolic variables to define functions
% We can define symbolic variables to let MATLAB know that these variables will 
% be used for exact computations

% Start by defining the variables as symbolic
syms t s x y

% Define a function by simply writing its expression

f = cos(t)
g = sin(t)
h = exp(2*x)

% We can manipulate these functions

simplify(f^2+g^2)
diff(h)

% We can plot a function defined symbolically using the command |ezplot|.
% Learn about the command |ezplot|:

help ezplot

% Plot the function |f(t)| and |h(x)|

ezplot(f)
ezplot(h)
%% 
% If we try to evaluate the function |f(0)|, we get an error message. 
% 
% The symbolic variables are not meant to be used to evaluate functions, but 
% to manipulate functions, compute derivatives, etc. To evaluate a function using 
% symbolic variables is a little cumbersome:

% We need to substitute the variable by a value:

subs(f,t,pi)
%% 
% This expression means: In the expression |f|, substitute the variable |t| 
% by the number |pi|.

% If we use a value where the cosine does not have a "nice" expression, we
% need to approximate the result:

subs(f,t,2)

% We need to use the command |eval|

eval(subs(f,t,2))
%% Exercise 7
% Objective: Define a function using symbolic variables and manipulate it.
% 
% Details: Define the function |f(x) = sin(x)cos(x)|
% 
% Use MATLAB commands to obtain a simpler form of this function, compute value 
% of this function for |x=pi/4| and |x=1|, and plot its graph.

syms x
%make the 2 functions
a=sin(x)
b=cos(x)

%combine the 2 functions
S=simplify(a.*b)

%evaluate the value of x=pi/4 and x=1 on the function
fprintf('at x=pi/4, f(x)=%g',subs(S,x,pi/4))
fprintf('at x=1, f(x)=%g',subs(S,x,1))
%plotting using ezplot
ezplot(a*b)
ylabel('y(x)')
%% Obtaining Picard approximations
% Consider an initial value problem
% 
% |y' = 1 + y| |y(0) = 0|
% 
% First we need to define the variables we will be using

syms t s y;

% We then need to define the function f

f = 1+y % we define it without the @(t,y) because it is a symbolic function

% We set up our initial approximation phi_0 = 0:

phi=[sym(0)]  % we will keep a list with all the approximations

% Set up a loop to get successive approximations using Picard iterations

N=5;

for i = 1:N
    func=subs(f,y,phi(i));    % prepare function to integrate: y -> previous phi
    func=subs(func,t,s);      % variable of integration is s, so we need to change
                              % t -> s
    
    newphi = int(func, s, 0 ,t);   % integrate to find next approximation
    
    phi=cat(2,phi,[newphi]);       % update the list of approximations by adding new phi
end

% Show the last approximation
phi
phi(N+1)

% Plot the approximation just found

picard=ezplot(phi(N+1),[0,5])
set(picard,'Color','green')         % set the color of the graph to green

% In this case, the exact solution is
%
% |y=e^t-1|
%
% Compare the approximation and the exact solutions

hold on;
exact=ezplot(exp(t)-1,[0,5]);

xlabel('t');
ylabel('y');
title('Picard Approximations');
legend('Picard Approximation', 'Exact Solution','Location','NorthWest');
clear all
%% Exercise 8
%%
% 
%  Objective: Solve your own Picard Approximation and compare it to the
%  exact solution.
%
%%
% 
%  Details: Consider the IVP
%     | y' = 1+y^2|
%     | y(0) = 1 |
%
%% 
% Find the Picard approximation phi_5. For better efficiency, do not keep all 
% the previous approximations.
% 
% Compute the exact solution (by hand), and plot both on the same figure for 
% comparison, as above.
% 
% Label your axes and include a legend.
% 
% HINT. The initial condition has 1 instead of 0, so the Picard method needs 
% to be adapted.

syms t s y;

% We then need to define the function f

f = 1+y.^2 % we define it without the @(t,y) because it is a symbolic function

% We set up our initial approximation phi_0 = 0:

phi=[sym(1)]  % we will keep a list with all the approximations

% Set up a loop to get successive approximations using Picard iterations

N=5;

for i = 1:N
    func=subs(f,y,phi(i));    % prepare function to integrate: y -> previous phi
    func=subs(func,t,s);      % variable of integration is s, so we need to change
                              % t -> s
    
    newphi = int(func, s, 0 ,t);   % integrate to find next approximation
    
    phi=cat(2,phi,[newphi]);       % update the list of approximations by adding new phi
end

% Show the last approximation

phi(N+1)

% Plot the approximation just found

picard=ezplot(phi(N+1),[0,5]);
set(picard,'Color','green');         % set the color of the graph to green

% In this case, the exact solution is
%
% |y=tan(t)|
%
% Compare the approximation and the exact solutions

hold on;
exact=ezplot(tan(t),[0,5]);

xlabel('t');
ylabel('y');
title('Picard Approximations');
legend('Picard Approximation', 'Exact Solution','Location','NorthWest');
clear all
##### SOURCE END #####
-->
</body>
</html>
